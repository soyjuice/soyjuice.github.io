---
layout: post
title: 动态规划专练（四）
categories: [NOI, 动态规划]
description: 老文章
mini-description: 对半吧，写这都快成偷懒的理由了
keywords: C++, 动态规划
---

# 1.采药

## 题目描述

辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”

如果你是辰辰，你能完成这个任务吗？
<!--more-->
## 输入格式

第一行有两个整数T（1 &lt;= T &lt;= 1000）和M（1 &lt;= M &lt;= 100），用一个空格隔开，T代表总共能够用来采药的时间，M代表山洞里的草药的数目。接下来的M行每行包括两个在1到100之间（包括1和100）的整数，分别表示采摘某株草药的时间和这株草药的价值。

## 输出格式

一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。

## **输入样例**

```
70 3
71 100
69 1
1 2
```

## 输出样例

```
3
```

## 说明

对于30%的数据，M &lt;= 10；

对于全部的数据，M &lt;= 100。

NOIP2005普及组第三题，也就是背包问题中的01背包。

代码：

``` cpp
#include<bits/stdc++.h>
using namespace std;

const int up=1000 +5;

int main()
{
    int t,m,ti,vi,f[up];
    memset(f,0,sizeof f);
    scanf("%d %d",&t,&m);
    while(m--)
    {
        scanf("%d %d",&ti,&vi);
        for(int i=t;i>=ti;i--) f[i]=max(f[i],f[i-ti]+vi);
    }
    printf("%d\n",f[t]);

    return 0;
}
```

对于 背包问题，我个人是这么认为的：

首先，**滚动数组**（其实就是压了并不重要的一维）是必然的，而且背包问题滚动数组更容易理解。

在01背包中，循环由大到小，如“for(int i=C;i&gt;=V;i--) f[i]=max(f[i],f[i-V]+W);”，较末的状态转移自较前的状态是背包问题也是大部分动态规划题目的特点，而较末的状态先被计算，对**同一个循环中的其它状态**是不会有影响的，因为较前的状态只会转移自比它更前的状态；而在完全背包中，循环由小到大，如“for(int i=V;i&lt;=C;i++) f[i]=max(f[i],f[i-V]+W);”，较前的状态先被计算，于是就有可能对**同一循环中之后的状态**造成影响。

至于剩下的一些背包问题，则是万变不离其宗，比如多重背包，可以看作有同种物品的01背包，还有混合背包，也可以同样看作是不同多种物品的01背包。

# 2.点集配对问题

## 问题描述

空间里有n个点P0,P1,P2,...,Pn-1，把它们分成n/2对，使得每个点恰好在一个点对中，且所有点对距离之和尽量小。

## 输入格式

第一行是整数n，数据保证n为偶数；接下来n行每行三个数，分别代表点i的x,y,z坐标。

## 输出格式

输出只有一行，为最小的所有点对距离之和，保留两位小数。

## 输入样例

```
4
1 1 1
1 1 2
1 4 3
1 6 6
```

## 输出样例

```
4.61
```

## 说明

n&lt;=20，|xi|,|yi|,|zi|&lt;=10000。

代码：

``` cpp
#include<bits/stdc++.h>
using namespace std;

const int up=20 +5;
const double inf=1e10;
struct node
{
    int x,y,z;
} g[up];
int n,k;
double f[1<<up];//二进制集合表示状态

double dis(int i,int j)
{
    return sqrt(((double)(g[i].x-g[j].x)*(g[i].x-g[j].x)+(g[i].y-g[j].y)*(g[i].y-g[j].y)+(g[i].z-g[j].z)*(g[i].z-g[j].z)));
}

int main()
{
    scanf("%d",&n);
    for(int i=0;i<n;i++) scanf("%d %d %d",&g[i].x,&g[i].y,&g[i].z);
    for(int i=1;i<(1<<n);i++)
    {
    f[i]=inf;
    for(k=0;k<n;k++) if(i&(1<<k)) break;
    for(int j(k+1);j<n;j++) if(i&(1<<j)) f[i]=min(f[i],dis(k,j)+f[i^(1<<j)^(1<<k)]);
    }
    printf("%.2lf",f[(1<<n)-1]);

    return 0;
}
```


代码本身没有什么亮点，但有一处值得注意，当遇到集合DP时可以考虑使用二进制代表集合。